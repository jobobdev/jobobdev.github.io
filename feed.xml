<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="https://jobobdev.github.io/blog/feed.xml" rel="self" type="application/atom+xml" /><link href="https://jobobdev.github.io/blog/" rel="alternate" type="text/html" hreflang="en" /><updated>2022-04-29T00:31:58+00:00</updated><id>https://jobobdev.github.io/blog/feed.xml</id><title type="html">Jobobdev</title><subtitle></subtitle><entry><title type="html">왜 (__name__)을 Flask class로 넘길까?</title><link href="https://jobobdev.github.io/blog/blog/2022/name-flask/" rel="alternate" type="text/html" title="왜 (__name__)을 Flask class로 넘길까?" /><published>2022-04-24T21:34:00+00:00</published><updated>2022-04-24T21:34:00+00:00</updated><id>https://jobobdev.github.io/blog/blog/2022/name-flask</id><content type="html" xml:base="https://jobobdev.github.io/blog/blog/2022/name-flask/"><![CDATA[<p><span style=" font-family: 'Gothic A1', sans-serif;font-size: 25px; font-weight: 500;">[app = Flask(<strong>name</strong>)]</span></p>

<p><span style="font-weight: 500;">Flask를 사용하게 되면 Flask(<strong>name</strong>)이라는 놈을 선언하게 된다. 무슨 역할을 하는 놈인지 한 번 알아보았다.</span></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>
</code></pre></div></div>

<p style="font-weight: 500;"><br />
<span style="font-size: 1.25rem;">Flask에 (__name__)을 인자로 넘겨준다.</span>
<br /><br />
<span>__name__ 은 모듈의 이름을 지칭한다.</span>
<br /><br />
<span>만약, 당신의 test.py 모듈의 위치가 최상위 디렉토리(directory)에 위치한다면</span><br />
<span>__name__ = test 이렇게 된다.</span><br /><br />
    
<span>그 모듈의 위치가 my_package 라는 패키지 안에 들어있다면</span><br />
<span>__name__ = my_package.test 가 되는 것이다.</span><br /><br />
    
<span style="font-size: 1.25rem;">예외 상황:</span><br /><br />
<span>1. __init__.py라는 명칭을 가진 패키지 모듈일 경우</span><br /><br />
<span>만약, 당신의 모듈이 my_package/__init__.py 의 경로를 가지고 있다면,</span><br />
<span>__name__ = my_package 이렇게 된다.</span><br /><br />
    
<span>2. 메인 모듈 안에 있을 경우</span><br /><br />
<span>만약, 당신이 python interpreter를 메인 모듈에서 구동한다면 그 땐,</span><br />
<span>__name__ = __main__ 이 되는 특수한 상황이 발생한다.</span>
<br /><br /><br />
</p>

<h2>왜 그렇게 될까?</h2>

<p>Flask의 첫 argument(인자)는 “import_name”이라고 불리운다. 그리고 이 “import_name”을 곧 “애플리케이션 패키지의 이름”이라고 설명하고있다.</p>

<p>이 <strong>“import_name”</strong>의 존재 이유는 크게 3가지로 정리할 수 있다:</p>

<ul>
  <li>파일시스템 안에서 리소스를 찾기 위해</li>
  <li>확장자를 통해 디버깅 정보를 개선하기 위해</li>
  <li>그 외 아주 많은 이유로 인해(..?)</li>
</ul>

<p>그럼 이게 다 뭔 소리일까?</p>

<h3><br />우선,</h3>

<p>여기서의 <strong>‘리소스’</strong>란 애플리케이션 구동에 필요한 <strong>‘추가적인 파일들’</strong>을 의미한다. 예를 들어, static 또는 template 파일들 말이다.</p>

<p><strong>작동원리는 다음과 같다.</strong></p>

<ol>
  <li>Flask는 “import_name”으로 넘겨진 인자를 받는다.</li>
  <li>그 인자는 import된 패키지의 명칭이다.</li>
  <li>그리고 Flask는 이 명칭을 이용해 애플리케이션 안의 경로를 찾아들어가 동일한 명칭을 가진 모듈을 파악한다.</li>
  <li>그렇게 경로를 알아내게 되면, Flask는 static 또는 template 디렉토리 명칭(directory names)을 사용해(append) 그 파일들을 취득한다.</li>
</ol>

<p>flask/helpers.py 모듈 안에는 이미 get_root_path()라는 함수가 들어있다. 이 함수를 이용하면, 당신의 애플리케이션 안에 존재하는 각 패키지들의 혹은 모듈의 경로를 찾아낸다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># 예를 들어 'microblog'라는 애플리케이션에 get_root_path() 사용해보자.
</span><span class="kn">from</span> <span class="nn">flask.helpers</span> <span class="kn">import</span> <span class="n">get_root_path</span>

<span class="c1"># the app package
</span><span class="n">get_root_path</span><span class="p">(</span><span class="s">'app'</span><span class="p">)</span>
<span class="s">'/home/miguel/microblog/app'</span>

<span class="c1"># the flask package
</span><span class="n">get_root_path</span><span class="p">(</span><span class="s">'flask'</span><span class="p">)</span>
<span class="s">'/home/miguel/microblog/venv/lib/python3.8/site-packages/flask'</span>

<span class="c1"># the config.py module
</span><span class="n">get_root_path</span><span class="p">(</span><span class="s">'config'</span><span class="p">)</span>
<span class="s">'/Users/mgrinberg/Documents/dev/python/microblog'</span>

<span class="c1"># the app/models.py module
</span><span class="n">get_root_path</span><span class="p">(</span><span class="s">'app.models'</span><span class="p">)</span>
<span class="s">'/Users/mgrinberg/Documents/dev/python/microblog/app'</span>

</code></pre></div></div>

<p>위에서 볼 수 있듯이 두 가지 경우로 나타난다.</p>

<ol>
  <li>Flask()의 <strong>“import_name”</strong>으로 애플리케이션의 “패키지 이름”을 넘겨주면, Flask는 <strong>패키지의 위치</strong>를 찾아낸다.</li>
  <li>Flask()의 <strong>“import_name”</strong>으로 애플리케이션의 “모듈 이름”을 넘겨주면, Flask는 <strong>모듈이 들어있는 패키지의 위치</strong>를 찾아낸다.</li>
</ol>

<h2><br />다음으로,</h2>

<p>Flask는 “instance floders”라는 매우 모호한 개념을 가지고 있다. 정의에 따르면, “instance floders”는 소스컨트롤의 지배를 받지 않는 설정파일(configuration files)를 저장할 수 있는 특수한 폴더라고 한다.</p>

<p>재밌는 건(말이라도 이렇게 해야..), “instance folders”의 위치를 추적하는 것 또한 <strong>“import_name”</strong>이라는 것. 즉, <strong>“import_name”</strong>을 이용해 instance의 위치를 찾고, 그곳에 subdirectory를 추가(append)하는 것이다.</p>

<p>이런 특성 때문에 root_path와 instance_path 둘 다 Flask constructor 를 통해 덮어쓸 수 있다.</p>

<h2><br />Flask 확장자를 통한 디버깅 정보 개선</h2>

<p>Flask extension(확장자)들 중 <strong>“import_name”</strong>을 사용하는 건 <strong>Flask-SQLAlchemy</strong>라고 한다.</p>

<p>Flask-SQLAlchemy는 <strong>get_debug_queries()</strong>라는 함수를 가지고 있는데 이것이 하는 일은</p>

<p><code class="language-plaintext highlighter-rouge">“collects and logs all the queries that are issued during the life of a request.”</code> 라고 한다.</p>

<p>내 멋대로 해석해보자면, 요청을 수행하는 시간 동안 발생한 모든 쿼리에 대해 기록을 남기고 수집하는 것이라고 이해할 수 있다.</p>

<p>기록하는 요소들 중에는 쿼리가 발생한(issued) 애플리케이션의 소스코드 상 위치도 있다고 한다.</p>

<h2><br />결론<br /></h2>

<p><span>여기서 기억해두면 쓸모 있을만한 개념은 다음으로 정리할 수 있을 것 같다.</span>
<br />
<br />
<span>1. 내 .py 모듈이 최상위 디렉토리에 위치할 땐, (**name**)이 모듈의 이름과 일치한다.</span><br />
<span>2. 내 .py 모듈이 어떤 패키지 안에 위치할 땐, (**name**)이 패키지.모듈의 이름과 일치한다.</span><br />
<span>3. Flask(**name**)를 하는 이유는 결국, Flask에게 나의 패키지의 경로를 알려주는 것이다. 즉, 모듈의 이름을 인자로 받아 그걸 근거로 경로를 추적해 결국 모듈이 “담긴" 패키지의 위치를 알아낸다.</span>
<br /><br />
<span>이렇게 오늘은 Flask를 사용할 때 보게 되는 Flask(__name__)에 대해 알아보았다. 이런 지식이 언젠가 나에게 실용적인 도움이 되었으면 좋겠다.</span><br /><br />
</p>]]></content><author><name></name></author><category term="learnings" /><category term="flask" /><category term="python" /><category term="sql" /><summary type="html"><![CDATA[passing (__name__) into Flask Class]]></summary></entry><entry><title type="html">M1 유저를 위한 Jekyll로 깃블로그 열기</title><link href="https://jobobdev.github.io/blog/blog/2022/gitblog-jekyll/" rel="alternate" type="text/html" title="M1 유저를 위한 Jekyll로 깃블로그 열기" /><published>2022-04-14T20:37:00+00:00</published><updated>2022-04-14T20:37:00+00:00</updated><id>https://jobobdev.github.io/blog/blog/2022/gitblog-jekyll</id><content type="html" xml:base="https://jobobdev.github.io/blog/blog/2022/gitblog-jekyll/"><![CDATA[<p><span style=" font-family: 'Gothic A1', sans-serif;font-size: 25px; font-weight: 500;">[M1 유저를 위한 Jeklly Gitblog 열기!]</span></p>

<p><span style="font-weight: 500;">M1 Mac 유저분들 중 Jekyll을 이용해 깃블로그를 처음 열고자 한다면 아래 준비사항을 미리 체크하자!</span><br /><br />
정보도 가이드도 없이 혼자 이것 저것 해보려다가 장장 열흘을 소모하며 깨달은 것들이니<br /> 
나처럼 M1 맥북도 처음, 개발도 처음, Github pages도 처음이라면 마음 급하게 먹지 말고<br />
준비사항을 모두 완료한 후 진행해보도록 하자.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. MacOS를 최신으로 업데이트 하기. 업데이트 후 꼭 재부팅 먼저!!
2. M1 유저의 경우 Terminal은 "Start with Roessta" 해제하기.
2-1. Finder/Applications/ 경로의 terminal 앱에서 우클릭 후 get info를 통해 해제 가능..
3. Xcode 설치 완료하기. (몇 시간이 걸릴지 모르는 고통스러운 과정이므로 인내심 필요! 미리 깔려있다면 Lucky.)
</code></pre></div></div>

<p>위 사항들이 모두 마무리 되었다면, 이제 순서대로 진행해보자.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. Homebrew 설치
2. Ruby 와 Jekyll 설치
3. Jekyll theme fork하고 레포지토리 이름 바꾸기
4. 블로그 호스팅
</code></pre></div></div>

<p style="font-weight:600; font-size: 1.2rem"><br /><br />[STEP 1. Homebrew 설치하기]</p>
<p>Terminal 앱을 켠후 아래 코드를 복사 붙여넣고 Enter를 누른다.
Homebrew는 macOS용 패키지 관리자이다. <br />
Homebrew를 통해 Appple 혹은 Linux 시스템에서 제공하지 않는 유용한 패키지를 다운받고 관리할 수 있다.</p>

<figure class="highlight"><pre><code class="language-terminal" data-lang="terminal"><span class="gp">/bin/bash -c "$</span><span class="o">(</span>curl <span class="nt">-fsSL</span> https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh<span class="o">)</span><span class="s2">"</span></code></pre></figure>

<p>설치가 완료되었다면, 터미널에 <code class="language-plaintext highlighter-rouge">which brew</code> 명령어를 통해 설치 경로를 확인한다.<br />
M1 유저의 경우 아래와 같이 나왔다면 정상적으로 설치 된 것이다.<br />
설치 후 <code class="language-plaintext highlighter-rouge">[command] + q</code>를 통해 터미널을 완전히 껐다 켜야 한다.</p>

<div class="language-s highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">/</span><span class="n">opt</span><span class="o">/</span><span class="n">homebrew</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">brew</span><span class="w">
</span></code></pre></div></div>

<p>만약 설치 후 homebrew가 몇 가지 command를 실시하라고 할 수도 있는데,<br />
그럴 경우에만 아래의 코드들을 차례로 실행해주자.</p>

<figure class="highlight"><pre><code class="language-terminal" data-lang="terminal"><span class="gp">echo "eval $</span><span class="o">(</span>/opt/homebrew/bin/brew shellenv<span class="o">)</span><span class="s2">" &gt;&gt; ~/.zprofile
</span><span class="gp">eval $</span><span class="s2">(/opt/homebrew/bin/brew shellenv)</span></code></pre></figure>

<p style="font-weight:600; font-size: 1.2rem"><br /><br />[STEP 2. Ruby 와 Jekyll 설치하기]</p>

<p>Ruby를 철치하기에 앞서 Ruby Manager를 설치해야 한다.<br />
Ruby Manager는 Ruby의 버전관리를 위한 것들로 여러 종류가 있다. RVM, rbenv, asdf, chruby 등등. 그러나 서로 호환이 되지 않아 한 가지만 설치해야 한다. Jekyll 깃블로그를 열고 싶은데 Ruby 설치에서만 여러번 좌절해본 결과, chruby라는 놈이 나를 ERROR의 굴레로부터 벗어나게 해주었기 때문에 본 포스팅은 chruby를 기준으로 한다.</p>

<p>그 전에 다른 ruby managers가 설치되어 있는지 확인해보자.</p>

<div class="language-s highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rvm</span><span class="w"> </span><span class="n">help</span><span class="w">
</span></code></pre></div></div>

<div class="language-s highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rbenv</span><span class="w"> </span><span class="n">help</span><span class="w">
</span></code></pre></div></div>

<div class="language-s highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">asdf</span><span class="w"> </span><span class="o">--</span><span class="n">help</span><span class="w">
</span></code></pre></div></div>

<p>이 Jobobdev 블로그 주인처럼 자신이 초보라면, 깔끔하게 기존의 것들을 지우고 아래의 chruby 가이드를 따르길 권장한다.</p>

<p><span style="font-weight:500; font-size: 1.1rem">아래의 명령어를 통해 chruby와 Ruby를 설치한다.</span></p>

<div class="language-s highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">brew</span><span class="w"> </span><span class="n">install</span><span class="w"> </span><span class="n">chruby</span><span class="w"> </span><span class="n">ruby</span><span class="o">-</span><span class="n">install</span><span class="w">
</span></code></pre></div></div>

<p>설치가 완료 되었다면 차례대로 아래의 명령어들을 실행해주자.</p>

<p><span style="font-weight:500; font-size: 1.1rem">M1 Mac</span></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">echo</span> <span class="s">"source /opt/homebrew/opt/chruby/share/chruby/chruby.sh"</span> <span class="o">&gt;&gt;</span> <span class="o">~/</span><span class="p">.</span><span class="n">zshrc</span>
<span class="n">echo</span> <span class="s">"source /opt/homebrew/opt/chruby/share/chruby/auto.sh"</span> <span class="o">&gt;&gt;</span> <span class="o">~/</span><span class="p">.</span><span class="n">zshrc</span>
<span class="n">echo</span> <span class="s">"chruby ruby-3.1.1"</span> <span class="o">&gt;&gt;</span> <span class="o">~/</span><span class="p">.</span><span class="n">zshrc</span>
</code></pre></div></div>

<p><span style="font-weight:500; font-size: 1.1rem">혹시 Intel Mac 이라면</span></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">echo</span> <span class="s">"source /usr/local/share/chruby/chruby.sh"</span> <span class="o">&gt;&gt;</span> <span class="o">~/</span><span class="p">.</span><span class="n">zshrc</span>
<span class="n">echo</span> <span class="s">"source /usr/local/share/chruby/auto.sh"</span> <span class="o">&gt;&gt;</span> <span class="o">~/</span><span class="p">.</span><span class="n">zshrc</span>
<span class="n">echo</span> <span class="s">"chruby ruby-3.1.1"</span> <span class="o">&gt;&gt;</span> <span class="o">~/</span><span class="p">.</span><span class="n">zshrc</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">[command] + q</code>로 Terminal을 재부팅 후 잘 설치 되었는지 버전을 확인하자.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ruby -v
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">ruby 3.1.1p18</code> 버전 이상이면 문제 없다.</p>

<p>이제 Jekyll 차례이다.<br />
터미널에 아래의 명령어로 <a href="https://jekyllrb.com/">Jekyll</a>을 설치한다.</p>

<div class="language-s highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">gem</span><span class="w"> </span><span class="n">install</span><span class="w"> </span><span class="n">bundler</span><span class="w"> </span><span class="n">jekyll</span><span class="w">
</span></code></pre></div></div>

<p>설치가 완료 되었다면, 다음으로 넘어가보자.</p>

<p style="font-weight:600; font-size: 1.2rem"><br /><br />[STEP 3. Jekyll theme fork하고 레포지토리 이름 바꾸기]</p>

<p>Github는 사용자들의 github page를 이용한 블로그 제작을 위해 몇 가지 테마를 제공하지만<br />
성에 차지 않으므로, Jekyll theme을 다운받아 사용할 것이다.</p>

<p>Github의 <code class="language-plaintext highlighter-rouge">username.github.io</code> Repository를 먼저 생성한 후 Jekyll theme repository를 자신의 repository로 clone하는 방법도 있지만, 항상 문제가 발생했으므로 훨씬 쉬운 방법을 소개하고자 한다.</p>

<p>먼저, 아래의 사이트들 중에서 마음에 드는 Jekyll 테마를 고른다.</p>

<ul>
  <li><a href="https://github.com/topics/jekyll-theme">GitHub.com #jekyll-theme repos</a></li>
  <li><a href="https://jamstackthemes.dev/ssg/jekyll/">jamstackthemes.dev</a></li>
  <li><a href="http://jekyllthemes.org/">jekyllthemes.org</a></li>
  <li><a href="https://jekyllthemes.io/">jekyllthemes.io</a></li>
  <li><a href="https://jekyll-themes.com/">jekyll-themes.com</a></li>
</ul>

<p>사이트마다 차이가 있지만, ‘다운로드’ 혹은 ‘Github’, ‘Homepage’ 등의 버튼을 통해 테마의 repository로 이동한다.</p>

<p>이젠 내가 적용한 <code class="language-plaintext highlighter-rouge">'al-folio'</code>테마 제작자의 방법을 따라할 것이다.<br />
<strong><em>(각자의 테마 제작자가 README.md에 설명해놓은 절차를 그대로 따르는 것을 매우매우 추천한다.)</em></strong></p>

<ul>
  <li>테마의 Github repository에서 자신의 <code class="language-plaintext highlighter-rouge">username.github.io</code>로 fork 한다.</li>
</ul>

<div class="row mt-3">
        <figure>

  <picture>
    <source media="(max-width: 480px)" srcset="/assets/img/al-folio-fork-480.webp" />
    <source media="(max-width: 800px)" srcset="/assets/img/al-folio-fork-800.webp" />
    <source media="(max-width: 1400px)" srcset="/assets/img/al-folio-fork-1400.webp" />
    <!-- Fallback to the original file -->
    <img class="img-fluid rounded z-depth-1" src="/assets/img/al-folio-fork.png" />

  </picture>

</figure>

</div>
<div class="row mt-3">
        <figure>

  <picture>
    <source media="(max-width: 480px)" srcset="/assets/img/fork-to-my-repo-480.webp" />
    <source media="(max-width: 800px)" srcset="/assets/img/fork-to-my-repo-800.webp" />
    <source media="(max-width: 1400px)" srcset="/assets/img/fork-to-my-repo-1400.webp" />
    <!-- Fallback to the original file -->
    <img class="img-fluid rounded z-depth-1" src="/assets/img/fork-to-my-repo.png" />

  </picture>

</figure>

</div>

<ul>
  <li>자신의 gitblog 프로젝트를 저장하고자 하는 폴더의 경로로 이동 후 jekyll을 설치한다.</li>
</ul>

<div class="language-s highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cd</span><span class="w"> </span><span class="o">/</span><span class="n">Users</span><span class="o">/</span><span class="n">myname</span><span class="o">/</span><span class="n">Desktop</span><span class="o">/</span><span class="n">myfolder</span><span class="o">/</span><span class="w">
</span><span class="n">git</span><span class="w"> </span><span class="n">clone</span><span class="w"> </span><span class="n">https</span><span class="o">://</span><span class="n">github.com</span><span class="o">/</span><span class="n">username</span><span class="o">/</span><span class="n">username.github.io.git</span><span class="w">
</span><span class="n">cd</span><span class="w"> </span><span class="o">&lt;</span><span class="n">your</span><span class="o">-</span><span class="n">repo</span><span class="o">-</span><span class="n">name</span><span class="o">&gt;</span><span class="w">
</span><span class="n">bundle</span><span class="w"> </span><span class="n">install</span><span class="w">
</span><span class="n">bundle</span><span class="w"> </span><span class="n">exec</span><span class="w"> </span><span class="n">jekyll</span><span class="w"> </span><span class="n">serve</span><span class="w">
</span></code></pre></div></div>

<ul>
  <li>모든 명령어가 문제 없이 실행 되었다면 마지막 명령어 이후 local server를 통해 자신의 블로그를 미리 볼 수 있다.</li>
</ul>

<figure class="highlight"><pre><code class="language-jekyll" data-lang="jekyll">AutoPages: Disabled/Not configured in site.config.
Pagination: Complete, processed 1 pagination page(s)
Jekyll Diagrams: Command Not Found: mmdc
done in 0.952 seconds.
Auto-regeneration: enabled for '/jobobdev.github.io'
Server address: http://127.0.0.1:4000
Server running... press ctrl-c to stop.</code></pre></figure>

<p style="font-weight:600; font-size: 1.2rem"><br /><br />[STEP 4. 블로그 호스팅 하기]</p>
<p>지금 단계까지 문제 없지 잘 진행했다면, 이제 블로그를 자신의 것으로 만든 후 호스팅하는 것만 남았다!
아직 나 역시 그 단계를 진행중이므로 더 많은 걸 소개할 순 없지만, 당장 로컬에서 말고 실제로 자신의 github page에 블로그 페이지가 올라간 것을 확인하고 싶을 것이기 때문에 빠르게 아래의 단계를 실행해보자.</p>

<ul>
  <li>먼저, username.github.io 폴더의 _config.yml 파일을 열고 기본적인 정보들을 수정한다.</li>
  <li>아래의 사진처럼, <code class="language-plaintext highlighter-rouge">baseurl</code>은 비워두고 <code class="language-plaintext highlighter-rouge">url</code>에 자신의 github page 주소를 넣어준다.</li>
</ul>
<div class="row mt-3">
        <figure>

  <picture>
    <source media="(max-width: 480px)" srcset="/assets/img/config-edit-first-480.webp" />
    <source media="(max-width: 800px)" srcset="/assets/img/config-edit-first-800.webp" />
    <source media="(max-width: 1400px)" srcset="/assets/img/config-edit-first-1400.webp" />
    <!-- Fallback to the original file -->
    <img class="img-fluid rounded z-depth-1" src="/assets/img/config-edit-first.png" />

  </picture>

</figure>

</div>
<ul>
  <li>그 다음 변경 사항들을 커밋하고 push해주면 자신의 github page 주소로 블로그가 호스팅 된 것을 확인할 수 있다.
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd [블로그 repository 경로]
git add .
git commit -m "test blog"
git push
</code></pre></div>    </div>
  </li>
</ul>

<p><strong>모든 단계를 잘 마무리 했다면 이제 편집과의 싸움이다!! 난 아직 싸우는 중…</strong></p>]]></content><author><name></name></author><category term="learnings" /><category term="blog" /><category term="jekyll" /><category term="mac" /><category term="m1" /><category term="ruby" /><summary type="html"><![CDATA[deploy your personal github page with Jekyll]]></summary></entry></feed>